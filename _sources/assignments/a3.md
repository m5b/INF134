A3: Custom Graphical Toolkit
============================

## Overview

Today we have a vast ecosystem of toolkits and frameworks to draw (pun intended, sort of.) upon when building a software user interface. Frameworks like Angular and React rely upon layers of abstraction to render visual components to a particular viewstate. While these abstractions make it possible for us to quickly build powerful user interfaces, they mask the underlying logic required to perform the most basic interactions. In this assignment, we will be peeling back the layers to improve our understanding of the fundamental logic that make graphical widgets work.


```{code-cell}
:tags: [remove-input]
```
## Assignment Introduction
When you build a user interface, you might decide that you need a button, a checkbox, a way to capture text input, or one of the many other widgets provided to you by your chosen toolkit. To accomplish this task, you will likely create that widget by writing some code similar to the following (assuming our toolkit of choice is HTML):

```code
 <button type="button">Click</button> 
```

When rendered in a browser we would see something similar to this:

%```html
 <button type="button">Click</button> 
%```

Pretty straightforward, right? Write some code, build it, and view it. The end result is a nice graphical widget that changes in visual appearance when we interact with it using a mouse or keyboard. But how is this widget actually created? 

Clearly, it is a graphical element displayed on a screen, but the `button` HTML tag does not describe it's shape, colors, and behaviors. What operations take place to compose a button into what we see and interact with on the screen? For this assignment you will answer these questions by building your own widget toolkit using drawing primitives.

Although there are many tools available for building a widget toolkit, we will to use the Javascript library for Scalable Vector Graphics called [SVG.js](https://svgjs.dev/docs/3.0/). SVG.js provides us with the basic primitives that we need to create custom widgets. Our Widgets, therefore, will be rendered in a browser.

```{note}
If you are not sure where to start, review the week 5 lectures for an overview on SVG.js and getting started with a simple button.
```

## Assignment Details

You must build 7 widgets (discussed below) using the starter framework provided below. You will write each of your widgets in its own TypeScript file, following the conventions established in the **`button.ts`** file. 

### Starter Code

A [starter repository](https://classroom.github.com/a/BLeOlYOJ) has been created for you and is available on GitHub Classroom.

If you are not familiar with how to use GitHub Classroom repositories, we will go over the setup process during the week 5 lecture.

### Repository Structure

The repository contains some basic files to help get you started. You are free to explore all of them, but you should only need to directly edit **`button.ts`** and the other widget files that you create.

```{note}
SVG.js has been through a few updates since this code was last written. Although we have tested the current code, it's possible that we find a bug or two along the way. Any updates to the core code will be released via GitHub and announced here and on Zulip.
```

### File Overview

Files you do not have to edit

: **`dist/bundle.js`**: The bundled javascript that contains all code necessary to deploy your program. This file is autogenerated by webpack and won't appear until you build.
: **`dist/index.html`**: The HTML page used to load your widgets into the browser. This simply provides an HTML wrapper for bundle.js, you should not have to edit (but you might want to if you think of a name for you toolkit).
: **`src/core.ts`**: The base classes required to build a widget. You will import from this file but you should not have to change it.


Files you do have to edit

: **`src/index.ts`**: This file is used to build your 'GUI'. You will instantiate and use your widgets from this file.
: **`src/button.ts`**: A single button type widget. The **`button`** class in this file is incomplete, but we will walkthrough how to get it working together in class.
: **`src/[your_widget].ts`**: Consider 'your_widget' a placeholder for each of the widget files you will create. You will create six additional widgets to complete your toolkit.



### Setting up your Workspace

The repository makes use of **`npm`**, **`webpack`**, and **`TypeScript`** to function. So the first thing you will want to do after cloning the repository is install these tools. All of the config files are prepared for you, so you should only need to install the tools in order to run the project. We will install these tools using NPM. If you do not have NPM installed, follow these instructions to install npm: [npm installation instructions](https://www.npmjs.com/get-npm).

After cloning the repository, open it up in your prefered code editing tool. If you are using an editor with a built-in terminal, then you can enter the following commands from within your tool. Otherwise, you will have to open your OS's default terminal and CD into the directory where you placed the repository.

First, install webpack. A detailed overview of getting started with webpack can be found at their website: [Getting Started | webpack](https://webpack.js.org/guides/getting-started/)

```code
npm install webpack webpack-cli --save-dev
```

If all goes well you should not see any critical errors in the post-installation output. If you do, reach out to your instructors for assistance. Next, install TypeScript and the TypeScript loader:

```code
npm install typescript ts-loader --save-dev
```

Again, you should not see any critical errors after install. Once complete, you should be able to run the project using **`npm`**:

```code
npm run build
```

This command might take a few seconds the first time you run it, but when complete you should see something similar to the following:

```code

> erasmas@1.0.0 build
> webpack

asset bundle.js 510 KiB [compared for emit] (name: main)
runtime modules 670 bytes 3 modules
cacheable modules 186 KiB
  ./src/index.ts 272 bytes [built] [code generated]
  ./src/core.ts 6.54 KiB [built] [code generated]
  ./src/button.ts 5.62 KiB [built] [code generated]
  ./node_modules/@svgdotjs/svg.js/dist/svg.esm.js 173 KiB [built] [code generated]
webpack 5.68.0 compiled successfully in 1973 ms
```

You are now ready to run the program. The simplest way is to open the **`index.html`** file in the **`dist`** directory. However, you may prefer to setup a live server to host your program. We will cover how to do this in class, so if you miss it, please check the lecture recordings for week 5!

## Assignment Requirements

Your final toolkit must include the following 7 widgets (visit Wikipedia's [Graphical widget](https://en.wikipedia.org/wiki/Graphical_widget) page detailed descriptions):
* Button
* Check Box
* Radio Button
* Text Box
* Scroll Bar
* Progress Bar
* Custom (your choice, can be anything!)

Each widget must also implement a basic state machine similar to the button example we covered in lecture. You may incorporate the starter code for the button widget provided in the repository and developed during class into your toolkit.

You are free to add as many features to your widgets as you like. In addition to matching the basic rules of these widgets (e.g., a button depresses, a scroll thumb slides, etc), to receive full credit your widgets must support the following features:

Button
: Visually change for at least three states (e.g., color change on hover).
: Expose a custom label property to set the text on the button.
: Expose an event handler that notifies consuming code when the button is clicked.
: Expose an event handler that notifies consuming code when the widget state has changed.

Check Box
: Visually support checked and unchecked states.
: Expose a custom label property to set the text that appears to the **right** of the check box.
: Expose an event handler that notifies consuming code when the checked state has changed.
: Expose an event handler that notifies consuming code when the widget state has changed.

Radio Button
: Visually support checked and unchecked states.
: Support 2 to __n__ number of buttons, where __n__ is set by the consuming code, with minimum of two, positioned vertically.
: Ensure that only one button can be checked at a time.
: Expose a custom label property to set the text that appears to the **right** of each button.
: Expose an event handler that notifies consuming code when the checked state has changed and which __n__ has been checked.
: Expose an event handler that notifies consuming code when the widget state has changed.

Text Box
: Visually support a caret `` | `` that informs the user about the position of the cursor. The caret should only be visually present when the widget has hover focus.
: Expose a custom property to get the text entered by the user.
: Expose an event handler that notifies consuming code when the text has changed.
: Expose an event handler that notifies consuming code when the widget state has changed.

Scroll Bar
: Expose a custom property to set the height of the scroll bar.
: Expose a custom property to get the position of the scroll thumb.
: Expose an event handler that notifies consuming code when the scroll thumb has moved and in which direction.
: Expose an event handler that notifies consuming code when the widget state has changed.

Progress Bar
: Expose a custom property to set the width of the progress bar.
: Expose a custom property to set the increment value of the progress bar.
: Expose a custom property to get the increment value of the progress bar.
: Expose a custom method to increment the value of the progress bar. The method should support an arbitrary numerical value from 0-100.
: Expose an event handler that notifies consuming code when the progress bar has incremented.
: Expose an event handler that notifies consuming code when the widget state has changed.

Custom (your choice)
: There are no requirements for this widget. You are free to create anything you want. Model your custom widget after something that already exists or design something novel. A good approach here might be to reflect on your work for A2 to identify any bad widgets that you think you could improve. However, note in the grading rubric that we will be applying a 'unique or novel' score to your custom widget. Widgets that are variations on the required widgets or commonplace in most UI's will likely get a lower score than something that suprises us. Feel free to inquire with the instructors if you are uncertain!

In addition to the features listed above, ALL widgets must implement the abstract methods required by the **`Widget`** class in the **`core.js`** file. For example, after implementing the **`move`** method, your widget should be positionable by consuming code (e.g., a programmer should be able to add your widget to a document and specify using X and Y coordinates where on the document it should be placed).

### Additional Requirements

#### Theme
You must create and apply a consistent theme to your toolkit. Your widgets, when rendered in the browser, should visually appear as if they belong together. Your design does not have to be groundbreaking! Your design skills are not going to be evaluated in this class, however, we are looking to see that you have thoughtfully applied the core principles of user centered design that you have been learning in your Informatics coursework. Spend some time to get to know the ins and outs of SVG.js. Learn its capabilities (pretty much anything you can do with vectors can be done with SVG.js) and decide what you want your theme to look like.

#### State Tables
Since each widget is required to raise state change events, you will need to create a state machine for each widget. Your first step in creating a state machine is to identify and define the states and transitions required for each widget. The best way to record this information is through a state table, like the one we discussed in the week 3 lecture. You must include each of these state tables in your submission.

#### Demo Program
Once your toolkit is complete, you will assemble all of your widgets into a single program to demonstrate their functionality. This program does not have to do anything in particular, it just needs to enable us to interact with your widgets. Your demo program should listen to all the exposed event handlers that you created for your widgets and output the information they pass to the browser console. When we grade your assignment, we will open the console and look for these messages to assess whether or not the feature has been implemented.

```{admonition} For Your Consideration
:class: warning

There is a lot of work to complete here! Although things may look easy at first, pay attention to the details. To complete this assignment there are many small tasks that you must take into account. Get started early, and make incremental progress on your work every day. You have a lot of time to complete this assignment because we want you to be thoughtful in how you implement the required features. A task that appears obvious at first glance will likely give you trouble as you work on it, so even though you have a lot of time, do not wait until the last week.

```

## Submission

For this assignment you will submit your materials in two parts: 

### Part 1

1) Your state tables should be listed by widget in a single document. Your state table document should have a cover page with your name, a brief description, and name of your toolkit. 

2) Your theme should, at the very least, be roughly sketched out before implementation. It does not have to have the polish of a visual designer, but should look consistent across all widgets.

3) A description and sketch of your planned custom widget. Your description should include an explanation of why you selected the widget. Note: you will not be bound to this widget in your final submission, but if you do change, please let us know.

Combine your state tables, theme, and custom widget selection into a single PDF document and submit by the deadline specified on Canvas.

### Part 2
	 
1) Your final toolkit and demo program should be submitted as a single **`.zip`** file by the deadline specified on Canvas.

```{admonition} For Your Consideration
:class: tip

A good practice to make habit is to regularly commit your code to a source control system like GitHub as you make progress. You are free to use your github repository as often as you like as you work on the assignment, however, if you need assistance from the course instructors we will ask that you provide us with a link to your GitHub repository and a running instance of your program first.

```

## Grading

Your assignment will be given an overall grade that is based on the completeness of the following items:

* All materials submitted on time: 0.5 pts
* Completeness of toolkit (2 pts/widget): 14 pts
	* Are all required widgets complete?
	* Are all required widget features complete?
* Toolkit and Demo program: 3.0 pts
	* Are all required program features complete? 
	* Are all widgets visually consistent?
	* Does the custom widget apply principles of good design?
	* Is the custom widget unique or novel in some way?
* Documentation and Design: 2.5 pts
	* Are all widgets supported by a state table?
	* Is a widget theme clearly explained?
	* Is a custom widget clearly explained?

Total: 20 pts
