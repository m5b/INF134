A3: Custom Graphical Toolkit
============================

## Overview

Today we have a vast ecosystem of toolkits and frameworks to draw (pun intended, sort of.) upon when building a software user interface. Frameworks like Angular and React rely upon layers of abstraction to render visual components to a particular viewstate. While these abstractions make it possible for us to quickly build powerful user interfaces, they mask the underlying logic required to perform the most basic interactions. In this assignment, we will be peeling back the layers to improve our understanding of the fundamental logic that make graphical widgets work.


```{code-cell}
:tags: [remove-input]
```
## Assignment Details
When you build a user interface, you might decide that you need a button, a checkbox, a way to capture text input, or one of the many other widgets provided to you by your chosen toolkit. To accomplish this task, you will likely create that widget by writing some code similar to the following (assuming our toolkit of choice is HTML):

```code
 <button type="button">Click</button> 
```

When rendered in a browser we would see something similar to this:

%```html
 <button type="button">Click</button> 
%```


Pretty straightforward, right? Write some code, build it, and view it. The end result is a nice graphical widget that changes in visual appearance when we interact with it using a mouse or keyboard. But how is this widget actually created? 

Clearly, it is a graphical element displayed on a screen, but the `button` HTML tag does not describe it's shape, colors, and behaviors. What operations take place to compose a button into what we see and interact with on the screen? For this assignment you will answer these questions by building your own widget toolkit using drawing primitives.

Although there are many tools available for building a widget toolkit, you will be required to use the Javascript library for Scalable Vector Graphics called [SVG.js](https://svgjs.com/). Your widgets, therefore, will be rendered in a browser. If you haven't yet, review the week 4 lecture for an overview on how to get started.

You must build 7 widgets (discussed below) using a basic state machine similar to the one we covered in lecture. You may incorporate the starter code for the button widget discussed in the lecture, and provided below, into your toolkit.

Your widgets should be confined to a single JavaScript file that other programmers can import and use in their own projects. For example, in the following starter code for a button widget notice how the actual toolkit is imported into the **`demo.js`** file, allowing consuming code to use it without knowing anything about the underlying button code (similar to the earlier HTML button example):


```javascript
// File name: demo.js

import {MyToolkit} from './mytoolkit.js';

// Implement a MyToolkit Button
var btn = new MyToolkit.Button;
btn.move(100,100);
btn.onclick(function(e){
	console.log(e);
});
```


```javascript
// File name: mytoolkit.js

import {SVG} from './svg.min.js';

var MyToolkit = (function() {
    var Button = function(){
        var draw = SVG().addTo('body').size('100%','100%');
        var rect = draw.rect(100,50).fill('red')
        var clickEvent = null

        rect.mouseover(function(){
            this.fill({ color: 'blue'})
        })
        rect.mouseout(function(){
            this.fill({ color: 'red'})
        })
        rect.mouseup(function(){
            this.fill({ color: 'red'})
        })
        rect.click(function(event){
            this.fill({ color: 'pink'})
            if(clickEvent != null)
                clickEvent(event)
        })
        return {
            move: function(x, y) {
                rect.move(x, y);
            },
            onclick: function(eventHandler){
                clickEvent = eventHandler
            }
        }
    }
return {Button}
}());

export{MyToolkit}

```

### Widget Requirements

Your final toolkit must include the following 7 widgets (visit Wikipedia's [Graphical widget](https://en.wikipedia.org/wiki/Graphical_widget) page detailed descriptions):
* Button
* Check Box
* Radio Button
* Text Box
* Scroll Bar
* Progress Bar
* Custom (your choice, can be anything!)

You are free to add as many features to your widgets as you like. In addition to matching the basic rules of these widgets (e.g., a button depresses, a scroll thumb slides, etc), to receive full credit your widgets must support the following features:

Button
: Visually change for at least three states (e.g., color change on hover).
: Expose a custom label property to set the text on the button.
: Expose an event handler that notifies consuming code when the button is clicked.
: Expose an event handler that notifies consuming code when the widget state has changed.

Check Box
: Visually support checked and unchecked states.
: Expose a custom label property to set the text that appears to the **right** of the check box.
: Expose an event handler that notifies consuming code when the checked state has changed.
: Expose an event handler that notifies consuming code when the widget state has changed.

Radio Button
: Visually support checked and unchecked states.
: Support 2 to __n__ number of buttons, where __n__ is set by the consuming code, with minimum of two, positioned vertically.
: Ensure that only one button can be checked at a time.
: Expose a custom label property to set the text that appears to the **right** of each button.
: Expose an event handler that notifies consuming code when the checked state has changed and which __n__ has been checked.
: Expose an event handler that notifies consuming code when the widget state has changed.

Text Box
: Visually support a caret `` | `` that informs the user about the position of the cursor. The caret should only be visually present when the widget has hover focus.
: Expose a custom property to get the text entered by the user.
: Expose an event handler that notifies consuming code when the text has changed.
: Expose an event handler that notifies consuming code when the widget state has changed.

Scroll Bar
: Expose a custom property to set the height of the scroll bar.
: Expose a custom property to get the position of the scroll thumb.
: Expose an event handler that notifies consuming code when the scroll thumb has moved and in which direction.
: Expose an event handler that notifies consuming code when the widget state has changed.

Progress Bar
: Expose a custom property to set the width of the progress bar.
: Expose a custom property to set the increment value of the progress bar.
: Expose a custom property to get the increment value of the progress bar.
: Expose a custom method to increment the value of the progress bar. The method should support an arbitrary numerical value from 0-100.
: Expose an event handler that notifies consuming code when the progress bar has incremented.
: Expose an event handler that notifies consuming code when the widget state has changed.

Custom (your choice)
: There are no requirements for this widget. You are free to create anything you want. Model your custom widget after something that already exists or design something novel.

In addition to the features listed above, ALL widgets should be positionable by consuming code (see the **`move`** function in the starter code). A programmer should be able to add your widget to a document and specify using X and Y coordinates where on the document it should be placed.

### Additional Requirements

#### Theme
You must create and apply a consistent theme to your toolkit. Your widgets, when rendered in the browser, should visually appear as if they belong together. Your design does not have to be groundbreaking! Your design skills are not going to be evaluated in this class, however, we are looking to see that you have thoughtfully applied the core principles of user centered design that you have been learning in your Informatics coursework.

#### State Tables
Since each widget is required to raise state change events, you will need to create a state machine for each widget. Your first step in creating a state machine is to identify and define the states and transitions required for each widget. The best way to record this information is through a state table, like the one we discussed in the week 4 lecture. You must include each of these state tables in your submission.

#### Documentation
Your widget code should be documented using the [JSDoc](https://jsdoc.app/) format. There are plugins for tools like VS Code that can simplify a lot of the work through auto generation. When you have finished your toolkit, you will use JSDoc to output your documentation to HTML.

#### Demo Program
Once your toolkit is complete, you will assemble all of your widgets into a single program to demonstrate their functionality. This program does not have to do anything in particular, it just needs to enable us to interact with your widgets. Your demo program should listen to all the exposed event handlers that you created for your widgets and output the information they pass to the browser console. When we grade your assignment, we will open the console and look for these messages to assess whether or not the feature has been implemented.

```{admonition} For Your Consideration
:class: warning

There is a lot of work to complete here! Although things may look easy at first, pay attention to the details. To complete this assignment there are many small tasks that you must take into account. Get started early, and make incremental progress on your work every day. You have a lot of time to complete this assignment because we want you to be thoughtful in how you implement the required features. A task that appears obvious at first glance will likely give you trouble as you work on it, so even though you have a lot of time, do not wait until the last week.

```

## Submission

For this assignment you will submit your materials in two ways: 

1) Your state tables should be listed by widget in a single PDF document. Your state table document should have a cover page with a screen shot of your demo program and link to the URL where your demo program is running. 
	 
2) Your toolkit, HTML documentation, and demo program should be maintained in a public GitHub repository (you can make it private after you receive your grade, if you like). If you don't have a GitHub account you will need to create one. Your HTML documentation should be accessible via a link from your demo program. Your demo program and documentation must be hosted on a public web server that we can access.

```{admonition} For Your Consideration
:class: tip

A good practice to make habit is to regularly commit your code to a source control system like GitHub as you make progress. You are free to use your github repository as often as you like as you work on the assignment, however, if you need assistance from the course instructors we will ask that you provide us with a link to your GitHub repository and a running instance of your program first.

```

## Grading

Your assignment will be given an overall grade that is based on the completeness of the following items:

* All materials submitted on time: 0.5 pts
* Submission format requirements met: 0.5 pts
* Completeness of toolkit (2 pts/widget): 14 pts
	* Are all required widgets complete?
	* Are all required widget features complete?
* Toolkit and Demo program: 2.5 pts
	* Are all required features complete? 
	* Are all widgets visually consistent?
* Documentation: 2.5 pts
	* Are all widgets supported by a state table?
	* Are all public facing features documented?

Total: 20 pts







